package lua

import (
	"fmt"
	"strings"
	"time"

	"github.com/hsoul/skconf/internal/ast"
	"github.com/hsoul/skconf/internal/generator"
)

const Language = "lua"

func init() {
	generator.Register(Language, NewLuaGenerator)
}

type luaGenerator struct {
	indent int
	buf    strings.Builder

	skillMap map[string]string
	stateMap map[string]string
}

func NewLuaGenerator() (generator.CodeGenerator, error) {
	return &luaGenerator{
		indent:   0,
		buf:      strings.Builder{},
		skillMap: make(map[string]string),
		stateMap: make(map[string]string),
	}, nil
}

func (l *luaGenerator) Generate(node ast.Node) string {
	l.generateNode(node)
	return l.buf.String()
}

func (l *luaGenerator) generateNode(node ast.Node) {
	switch n := node.(type) {
	case *ast.Program:
		l.generateProgram(n)
	case *ast.SkillDef:
		l.generateSkillDef(n)
	case *ast.StateDef:
		l.generateStateDef(n)
	case *ast.FunctionDef:
		l.generateFunctionDef(n)
	case *ast.VarStatement:
		l.generateVarStatement(n)
	case *ast.ImportStatement:
		l.generateImportStatement(n)
	case *ast.ReturnStatement:
		l.generateReturnStatement(n)
	case *ast.ExprStmt:
		l.buf.WriteString(l.indent_str())
		l.generateExpression(n.Expression)
		l.buf.WriteString("\n")
	case *ast.IfStatement:
		l.generateIfStatement(n)
	case *ast.ForStatement:
		l.generateForStatement(n)
	case *ast.TableDef:
		l.generateTableDef(n)
	case *ast.CodeBlock:
		if n.Statements != nil {
			for _, stmt := range n.Statements {
				l.generateNode(stmt)
			}
		}
	default:
		l.buf.WriteString(fmt.Sprintf("-- Unhandled node type: %T\n", node))
	}
}

func (l *luaGenerator) indent_str() string {
	return strings.Repeat("    ", l.indent)
}

func (l *luaGenerator) generateProgram(program *ast.Program) {
	l.buf.WriteString("-- Generated by DSL\n")
	l.buf.WriteString("-- " + time.Now().Format("2006-01-02 15:04:05") + "\n\n")

	l.generateHeader()

	for _, imp := range program.Imports {
		l.generateNode(&imp)
	}

	if len(program.Imports) > 0 {
		l.buf.WriteString("\n")
	}

	for _, stmt := range program.Statements {
		l.generateNode(stmt)
		if isBlockStatement(stmt) {
			l.buf.WriteString("\n")
		}
	}

	l.generateExport()
}

func isBlockStatement(stmt ast.Statement) bool {
	switch stmt.(type) {
	case *ast.SkillDef, *ast.StateDef:
		return true
	default:
		return false
	}
}

func (l *luaGenerator) generateHeader() {
	l.buf.WriteString("local UE = RE\n")
	l.buf.WriteString("local UF = FC\n")
	l.buf.WriteString("\n")
}

func (l *luaGenerator) generateExport() {
	if len(l.skillMap) == 0 && len(l.stateMap) == 0 {
		return
	}

	l.buf.WriteString("return {\n")
	l.indent++

	if len(l.skillMap) > 0 {
		l.buf.WriteString(l.indent_str())
		l.buf.WriteString("skills = {\n")
		l.indent++

		for tid, name := range l.skillMap {
			l.buf.WriteString(l.indent_str())
			l.buf.WriteString(fmt.Sprintf("[%s] = %s,\n", tid, name))
		}

		l.indent--
		l.buf.WriteString(l.indent_str())
		l.buf.WriteString("},\n")
	}

	if len(l.stateMap) > 0 {
		l.buf.WriteString(l.indent_str())
		l.buf.WriteString("states = {\n")
		l.indent++

		for tid, name := range l.stateMap {
			l.buf.WriteString(l.indent_str())
			l.buf.WriteString(fmt.Sprintf("[%s] = %s,\n", tid, name))
		}

		l.indent--
		l.buf.WriteString(l.indent_str())
		l.buf.WriteString("}\n")
	}

	l.indent--
	l.buf.WriteString("}")
}
